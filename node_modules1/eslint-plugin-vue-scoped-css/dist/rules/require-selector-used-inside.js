"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const selectors_1 = require("../styles/selectors");
const selectors_2 = require("../styles/utils/selectors");
const query_1 = require("../styles/selectors/query");
const options_1 = require("../options");
const context_1 = require("../styles/context");
const utils_1 = require("../utils/utils");
function getScopedSelectors(style) {
    const resolvedSelectors = selectors_1.getResolvedSelectors(style);
    return resolvedSelectors.map(getScopedSelector);
}
function getScopedSelector(resolvedSelector) {
    const { selector } = resolvedSelector;
    const deepIndex = selector.findIndex(selectors_2.isDeepCombinator);
    return deepIndex >= 0 ? selector.slice(0, deepIndex) : [...selector];
}
module.exports = {
    meta: {
        docs: {
            description: "Reports the defined selectors is not used inside `<template>`.",
            category: undefined,
            default: "warn",
            url: "https://future-architect.github.io/eslint-plugin-vue-scoped-css/rules/require-selector-used-inside.html",
        },
        fixable: null,
        messages: {
            unused: "The selector `{{selector}}` is unused in the template.",
        },
        schema: [
            {
                type: "object",
                properties: {
                    ignoreBEMModifier: {
                        type: "boolean",
                    },
                    captureClassesFromDoc: {
                        type: "array",
                        items: [
                            {
                                type: "string",
                            },
                        ],
                        minItems: 0,
                        uniqueItems: true,
                    },
                },
                additionalProperties: false,
            },
        ],
        type: "suggestion",
    },
    create(context) {
        if (!utils_1.hasTemplateBlock(context)) {
            return {};
        }
        const styles = context_1.getStyleContexts(context)
            .filter(context_1.StyleContext.isValid)
            .filter(style => style.scoped);
        if (!styles.length) {
            return {};
        }
        const reporter = context_1.getCommentDirectivesReporter(context);
        const reportedSet = new Set();
        function report(nodes) {
            const last = nodes[nodes.length - 1];
            if (!reportedSet.has(last)) {
                reporter.report({
                    loc: {
                        start: nodes[0].loc.start,
                        end: last.loc.end,
                    },
                    messageId: "unused",
                    data: {
                        selector: nodes.map(n => n.selector).join(""),
                    },
                });
                reportedSet.add(last);
            }
        }
        function verifySelector(queryContext, scopedSelector) {
            let targetsQueryContext = queryContext;
            const selectorNodes = scopedSelector
                .filter(s => selectors_2.isSelectorCombinator(s) ||
                selectors_2.isTypeSelector(s) ||
                selectors_2.isIDSelector(s) ||
                selectors_2.isClassSelector(s) ||
                selectors_2.isUniversalSelector(s));
            for (let index = 0; index < selectorNodes.length; index++) {
                const selectorNode = selectorNodes[index];
                targetsQueryContext = targetsQueryContext.queryStep(selectorNode);
                if (!targetsQueryContext.elements.length) {
                    report(selectorNodes.slice(0, index + 1));
                    break;
                }
            }
        }
        return {
            "Program:exit"() {
                const queryContext = query_1.createQueryContext(context, options_1.ParsedQueryOptions.parse(context.options[0]));
                for (const style of styles) {
                    for (const scopedSelector of getScopedSelectors(style)) {
                        verifySelector(queryContext, scopedSelector);
                    }
                }
            },
        };
    },
};
