"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const css_nodes_1 = require("./css-nodes");
function hasNodesSelector(node) {
    return (node != null &&
        (node.type === "VCSSSelector" || node.type === "VCSSSelectorPseudo"));
}
exports.hasNodesSelector = hasNodesSelector;
function isVDeepPseudo(node) {
    if (isPseudo(node)) {
        const val = node.value.trim();
        return val === "::v-deep";
    }
    return false;
}
exports.isVDeepPseudo = isVDeepPseudo;
function isTypeSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSTypeSelector";
}
exports.isTypeSelector = isTypeSelector;
function isIDSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSIDSelector";
}
exports.isIDSelector = isIDSelector;
function isClassSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSClassSelector";
}
exports.isClassSelector = isClassSelector;
function isUniversalSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSUniversalSelector";
}
exports.isUniversalSelector = isUniversalSelector;
function isNestingSelector(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSNestingSelector";
}
exports.isNestingSelector = isNestingSelector;
function isPseudo(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSSelectorPseudo";
}
exports.isPseudo = isPseudo;
function isSelectorCombinator(node) {
    return (node === null || node === void 0 ? void 0 : node.type) === "VCSSSelectorCombinator" || isVDeepPseudo(node);
}
exports.isSelectorCombinator = isSelectorCombinator;
function isDescendantCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "";
}
exports.isDescendantCombinator = isDescendantCombinator;
function isChildCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === ">";
}
exports.isChildCombinator = isChildCombinator;
function isAdjacentSiblingCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "+";
}
exports.isAdjacentSiblingCombinator = isAdjacentSiblingCombinator;
function isGeneralSiblingCombinator(node) {
    return isSelectorCombinator(node) && node.value.trim() === "~";
}
exports.isGeneralSiblingCombinator = isGeneralSiblingCombinator;
function isDeepCombinator(node) {
    if (isSelectorCombinator(node)) {
        const val = node.value.trim();
        return val === ">>>" || val === "/deep/" || isVDeepPseudo(node);
    }
    return false;
}
exports.isDeepCombinator = isDeepCombinator;
function isNestingAtRule(node) {
    if (node == null) {
        return false;
    }
    return css_nodes_1.isVCSSAtRule(node) && node.name === "nest" && node.identifier === "@";
}
exports.isNestingAtRule = isNestingAtRule;
function* findNestingSelectors(nodes) {
    for (const node of nodes) {
        if (isNestingSelector(node)) {
            yield {
                nestingIndex: nodes.indexOf(node),
                node,
                nodes,
            };
        }
        if (hasNodesSelector(node)) {
            yield* findNestingSelectors(node.nodes);
        }
    }
}
exports.findNestingSelectors = findNestingSelectors;
function findNestingSelector(nodes) {
    for (const nest of findNestingSelectors(nodes)) {
        return nest;
    }
    return null;
}
exports.findNestingSelector = findNestingSelector;
